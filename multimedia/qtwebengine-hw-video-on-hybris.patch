From fcba0e396d01187e0e09e1dfc531200a4b0d961d Mon Sep 17 00:00:00 2001
From: Alfred Neumayer <dev.beidl@gmail.com>
Date: Sun, 25 Dec 2022 16:00:25 +0100
Subject: [PATCH] qtwebengine-chromium: Add VP8, VP9 & H264 video decoding
 support

Uses libhybris' libmedia_compat_layer to achieve video decoding.
Because of issues feeding some decoders with relevant CSD it is
possible to disable H264 support via "setprop ubuntu.h264.supported false".
---
 .../chromium/media/gpu/BUILD.gn               |  18 +-
 .../media/gpu/hybris/video_decoder_hybris.cc  | 923 ++++++++++++++++++
 .../media/gpu/hybris/video_decoder_hybris.h   | 193 ++++
 .../chromium/media/media_options.gni          |   2 +-
 .../chromium/media/mojo/services/BUILD.gn     |   8 +
 .../mojo/services/gpu_mojo_media_client.cc    |  37 +-
 src/core/core_module.pro                      |   2 +-
 7 files changed, 1171 insertions(+), 12 deletions(-)
 create mode 100644 qtwebengine-chromium/chromium/media/gpu/hybris/video_decoder_hybris.cc
 create mode 100644 qtwebengine-chromium/chromium/media/gpu/hybris/video_decoder_hybris.h

diff --git a/qtwebengine-chromium/chromium/media/gpu/BUILD.gn b/qtwebengine-chromium/chromium/media/gpu/BUILD.gn
index b1a84b1ad..03369097a 100644
--- a/qtwebengine-chromium/chromium/media/gpu/BUILD.gn
+++ b/qtwebengine-chromium/chromium/media/gpu/BUILD.gn
@@ -5,12 +5,12 @@
 import("//build/buildflag_header.gni")
 import("//build/config/features.gni")
 import("//build/config/ui.gni")
+import("//build/config/linux/pkg_config.gni")
 import("//gpu/vulkan/features.gni")
 import("//media/gpu/args.gni")
 import("//media/media_options.gni")
 import("//testing/test.gni")
 import("//tools/generate_stubs/rules.gni")
-
 buildflag_header("buildflags") {
   header = "buildflags.h"
 
@@ -20,7 +20,11 @@ buildflag_header("buildflags") {
     "USE_LIBV4L2=$use_v4lplugin",
   ]
 }
-
+pkg_config("libmedia") {
+  packages = [
+    "libmedia",
+  ]
+}
 component("gpu") {
   output_name = "media_gpu"
 
@@ -94,6 +98,16 @@ component("gpu") {
     public_deps += [ "//media/gpu/mac" ]
   }
 
+  if (is_linux) {
+    defines += [ "ENABLE_HYBRIS_MEDIA" ]
+    sources += [
+      "hybris/video_decoder_hybris.cc",
+      "hybris/video_decoder_hybris.h",
+      "//media/base/android/extract_sps_and_pps.cc",
+      "//media/base/android/extract_sps_and_pps.h",
+    ]
+  }
+
   if (is_android) {
     sources += [
       "android/android_video_surface_chooser.cc",
diff --git a/qtwebengine-chromium/chromium/media/gpu/hybris/video_decoder_hybris.cc b/qtwebengine-chromium/chromium/media/gpu/hybris/video_decoder_hybris.cc
new file mode 100644
index 000000000..fd6f43593
--- /dev/null
+++ b/qtwebengine-chromium/chromium/media/gpu/hybris/video_decoder_hybris.cc
@@ -0,0 +1,923 @@
+// Copyright 2022 Alfred Neumayer. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "media/gpu/hybris/video_decoder_hybris.h"
+#include "media/formats/mp4/box_definitions.h"
+#include "base/task/task_traits.h"
+#include "base/task/thread_pool.h"
+#include "base/time/time.h"
+#include "gpu/ipc/service/command_buffer_stub.h"
+#include "ui/gl/gl_bindings.h"
+#include "ui/gl/gl_context.h"
+#include "ui/gl/gl_implementation.h"
+#include "ui/gl/gl_surface.h"
+#include "ui/gl/scoped_binders.h"
+#include "ui/gl/init/gl_factory.h"
+
+#include <hybris/properties/properties.h>
+
+#define BUFFER_FLAG_KEY_FRAME        1
+#define BUFFER_FLAG_CODEC_CONFIG     2
+#define BUFFER_FLAG_END_OF_STREAM    4
+#define INFO_TRY_AGAIN_LATER        -1
+#define INFO_OUTPUT_FORMAT_CHANGED  -2
+#define INFO_OUTPUT_BUFFERS_CHANGED -3
+
+extern "C" {
+int media_compat_check_availability();
+}
+
+namespace {
+
+bool IsH264Enabled() {
+  char value[PROP_VALUE_MAX];
+
+  if (::property_get("ubuntu.h264.supported", value, "true") <= 0) {
+    return true;
+  }
+
+  return (std::string(value) == "true");
+}
+
+}
+
+namespace media {
+
+// Support decoders without CSD for now
+static const char* kVideoMimeTypeH264 = "video/avc";
+static const char* kVideoMimeTypeVP8 = "video/x-vnd.on2.vp8";
+static const char* kVideoMimeTypeVP9 = "video/x-vnd.on2.vp9";
+static const char* kVideoMimeTypeHEVC = "video/hevc";
+
+std::vector<SupportedVideoDecoderConfig> HybrisMediaCodecVideoDecoder::GetSupportedConfigs() {
+  static const auto configs = GetSupportedConfigsInternal();
+  return configs;
+}
+
+std::vector<SupportedVideoDecoderConfig> HybrisMediaCodecVideoDecoder::GetSupportedConfigsInternal() {
+  std::vector<SupportedVideoDecoderConfig> supported_configs;
+
+  // We don't compile support into libvpx for these profiles, so allow them
+  // for all resolutions. See notes on H264 profiles below for more detail.
+  supported_configs.emplace_back(VP8PROFILE_MIN, VP8PROFILE_MAX,
+                                 gfx::Size(0, 0),
+                                 gfx::Size(3840, 2160),
+                                 true,    // allow_encrypted
+                                 false);  // require_encrypted
+  supported_configs.emplace_back(VP8PROFILE_MIN, VP8PROFILE_MAX,
+                                 gfx::Size(0, 0),
+                                 gfx::Size(2160, 3840),
+                                 true,    // allow_encrypted
+                                 false);  // require_encrypted
+
+  // Encrypted content must be decoded by MediaCodec.
+  supported_configs.emplace_back(VP8PROFILE_MIN, VP8PROFILE_MAX,
+                                 gfx::Size(0, 0),
+                                 gfx::Size(3840, 2160),
+                                 true,   // allow_encrypted
+                                 true);  // require_encrypted
+  supported_configs.emplace_back(VP8PROFILE_MIN, VP8PROFILE_MAX,
+                                 gfx::Size(0, 0),
+                                 gfx::Size(2160, 3840),
+                                 true,   // allow_encrypted
+                                 true);  // require_encrypted
+
+  // We don't compile support into libvpx for these profiles, so allow them
+  // for all resolutions. See notes on H264 profiles below for more detail.
+  supported_configs.emplace_back(VP9PROFILE_MIN, VP9PROFILE_MAX,
+                                 gfx::Size(0, 0),
+                                 gfx::Size(3840, 2160),
+                                 true,    // allow_encrypted
+                                 false);  // require_encrypted
+  supported_configs.emplace_back(VP9PROFILE_MIN, VP9PROFILE_MAX,
+                                 gfx::Size(0, 0),
+                                 gfx::Size(2160, 3840),
+                                 true,    // allow_encrypted
+                                 false);  // require_encrypted
+
+  // Encrypted content must be decoded by MediaCodec.
+  supported_configs.emplace_back(VP9PROFILE_MIN, VP9PROFILE_MAX,
+                                 gfx::Size(0, 0),
+                                 gfx::Size(3840, 2160),
+                                 true,   // allow_encrypted
+                                 true);  // require_encrypted
+  supported_configs.emplace_back(VP9PROFILE_MIN, VP9PROFILE_MAX,
+                                 gfx::Size(0, 0),
+                                 gfx::Size(2160, 3840),
+                                 true,   // allow_encrypted
+                                 true);  // require_encrypted
+
+  if (IsH264Enabled()) {
+    supported_configs.emplace_back(H264PROFILE_MIN, H264PROFILE_MAX,
+                                   gfx::Size(0, 0), gfx::Size(3840, 2160),
+                                   true,    // allow_encrypted
+                                   false);  // require_encrypted
+    supported_configs.emplace_back(H264PROFILE_MIN, H264PROFILE_MAX,
+                                   gfx::Size(0, 0), gfx::Size(2160, 3840),
+                                   true,    // allow_encrypted
+                                   false);  // require_encrypted
+
+    supported_configs.emplace_back(H264PROFILE_MIN, H264PROFILE_MAX,
+                                   gfx::Size(0, 0), gfx::Size(3840, 2160),
+                                   true,    // allow_encrypted
+                                   true);  // require_encrypted
+    supported_configs.emplace_back(H264PROFILE_MIN, H264PROFILE_MAX,
+                                   gfx::Size(0, 0), gfx::Size(2160, 3840),
+                                   true,    // allow_encrypted
+                                   true);  // require_encrypted
+  }
+
+  supported_configs.emplace_back(HEVCPROFILE_MIN, HEVCPROFILE_MAX,
+                                 gfx::Size(0, 0), gfx::Size(3840, 2160),
+                                 true,    // allow_encrypted
+                                 false);  // require_encrypted
+  supported_configs.emplace_back(HEVCPROFILE_MIN, HEVCPROFILE_MAX,
+                                 gfx::Size(0, 0), gfx::Size(2160, 3840),
+                                 true,    // allow_encrypted
+                                 false);  // require_encrypted
+
+  supported_configs.emplace_back(HEVCPROFILE_MIN, HEVCPROFILE_MAX,
+                                 gfx::Size(0, 0), gfx::Size(3840, 2160),
+                                 true,    // allow_encrypted
+                                 true);  // require_encrypted
+  supported_configs.emplace_back(HEVCPROFILE_MIN, HEVCPROFILE_MAX,
+                                 gfx::Size(0, 0), gfx::Size(2160, 3840),
+                                 true,    // allow_encrypted
+                                 true);  // require_encrypted
+
+  return supported_configs;
+}
+
+  HybrisMediaCodecVideoDecoder::HybrisMediaCodecVideoDecoder(
+      scoped_refptr<base::SingleThreadTaskRunner> task_runner,
+      scoped_refptr<base::SingleThreadTaskRunner> gpu_task_runner,
+      GetStubCB stub_cb) :
+        running_(false),
+        filling_(false),
+        draining_(false),
+        n_buffers_in_(0),
+        queue_timeout_(10000),
+        media_codec_(nullptr),
+        media_codec_configured_(0),
+        media_codec_started_(0),
+        media_format_(nullptr),
+        stc_(nullptr),
+        task_runner_(task_runner),
+        gpu_task_runner_(gpu_task_runner),
+        supportsH264_(IsH264Enabled()),
+        frame_duration_calculator_(32) {
+    gpu::CommandBufferStub* stub = std::move(stub_cb).Run();
+    decoder_context_ = stub->decoder_context();
+    decoder_helper_ = GLES2DecoderHelper::Create(decoder_context_);
+  }
+
+  HybrisMediaCodecVideoDecoder::~HybrisMediaCodecVideoDecoder()  {
+    Destroy();
+  }
+
+  bool HybrisMediaCodecVideoDecoder::IsSupportedProfile(VideoCodecProfile type)
+  {
+    if ((IsH264Enabled() && (type >= H264PROFILE_MIN && type <= H264PROFILE_MAX)) ||
+        (type >= VP8PROFILE_MIN && type <= VP8PROFILE_MAX) ||
+        (type >= VP9PROFILE_MIN && type <= VP9PROFILE_MAX) ||
+        (type >= HEVCPROFILE_MIN && type <= HEVCPROFILE_MAX)) {
+      return true;
+    }
+    return false;
+  }
+
+  bool HybrisMediaCodecVideoDecoder::IsSupported(VideoCodecProfile type)
+  {
+    if (!IsSupportedProfile(type)) {
+      return false;
+    }
+
+    const char* hybris_codec_type = MimeTypeForCodecType(type);
+    if (!hybris_codec_type) {
+      return false;
+    }
+
+    std::string codec_type = std::string(hybris_codec_type);
+    std::string hybris_codec_name = FindSuitableCodec(codec_type, true);
+    if (hybris_codec_name.length() == 0) {
+      hybris_codec_name = FindSuitableCodec(codec_type, false);
+    }
+    return (hybris_codec_name.length() > 0);
+  }
+
+  const char* HybrisMediaCodecVideoDecoder::MimeTypeForCodecType(VideoCodecProfile type) {
+    if (IsH264Enabled() && (type >= H264PROFILE_MIN && type <= H264PROFILE_MAX)) {
+      return kVideoMimeTypeH264;
+    } else if (type >= VP8PROFILE_MIN && type <= VP8PROFILE_MAX) {
+      return kVideoMimeTypeVP8;
+    } else if (type >= VP9PROFILE_MIN && type <= VP9PROFILE_MAX) {
+      return kVideoMimeTypeVP9;
+    } else if (type >= HEVCPROFILE_MIN && type <= HEVCPROFILE_MAX) {
+      return kVideoMimeTypeHEVC;
+    }
+    return nullptr;
+  }
+
+  std::string HybrisMediaCodecVideoDecoder::FindSuitableCodec(const std::string& codec_type, const bool hwCodecOnly) {
+    std::string hybris_codec_name;
+
+    // Find a decoder corresponding to our requested type
+    const size_t media_codec_num = media_codec_list_count_codecs();
+    for (size_t media_codec_pos = 0; media_codec_pos < media_codec_num; media_codec_pos++) {
+      media_codec_list_get_codec_info_at_id(media_codec_pos);
+
+      if (media_codec_list_is_encoder(media_codec_pos))
+        continue;
+
+      const char* codec_name_ptr = media_codec_list_get_codec_name(media_codec_pos);
+      if (!codec_name_ptr)
+        continue;
+
+      std::string codec_name(codec_name_ptr);
+
+      if (hwCodecOnly) {
+        if (codec_name.rfind("OMX.google.", 0) == 0)
+          continue;
+      }
+
+      LOG(INFO) << "Inspecting codec: " << codec_name;
+
+      const size_t num_supported_types = media_codec_list_get_num_supported_types(media_codec_pos);
+      for (size_t supported_type_pos = 0; supported_type_pos < num_supported_types; supported_type_pos++) {
+        const size_t mime_len = media_codec_list_get_nth_supported_type_len(media_codec_pos, supported_type_pos);
+        if (mime_len == 0)
+          continue;
+
+        char* potential_mime = new char[mime_len + 1]();
+        media_codec_list_get_nth_supported_type(media_codec_pos, potential_mime, supported_type_pos);
+        if (!potential_mime)
+          continue;
+
+        potential_mime[mime_len] = '\0';
+        std::string potential_type(potential_mime);
+        LOG(INFO) << "Type: " << potential_type;
+
+        if (potential_type == codec_type) {
+          LOG(INFO) << "Found codec for type " << potential_type << ", called " << codec_name;
+          hybris_codec_name = codec_name;
+          delete[] potential_mime;
+          break;
+        }
+
+        delete[] potential_mime;
+      }
+
+      if (hybris_codec_name.length() > 0)
+        break;
+    }
+
+    return hybris_codec_name;
+  }
+
+bool HybrisMediaCodecVideoDecoder::IsPlatformDecoder() const {
+  return true;
+}
+
+bool HybrisMediaCodecVideoDecoder::SupportsDecryption() const {
+  return false;
+}
+
+void HybrisMediaCodecVideoDecoder::Initialize(
+                const VideoDecoderConfig& config,
+                bool low_delay,
+                CdmContext* cdm_context,
+                InitCB init_cb,
+                const OutputCB& output_cb,
+                const WaitingCB& waiting_cb) {
+  if (!IsSupportedProfile(config.profile())) {
+    return;
+  }
+
+  // Initialize hybris compat layer
+  const char* hybris_codec_type = MimeTypeForCodecType(config.profile());
+  if (!hybris_codec_type) {
+    return;
+  }
+
+  codec_type_ = std::string(hybris_codec_type);
+
+  // Look for hardware-codecs first
+  std::string hybris_codec_name = FindSuitableCodec(codec_type_, true);
+  if (hybris_codec_name.length() == 0) {
+    LOG(INFO) << "Didn't find a suitable Hybris codec";
+    std::move(init_cb).Run(StatusCode::kDecoderInitializationFailed);
+    return;
+  }
+
+  media_codec_ = media_codec_create_by_codec_name(hybris_codec_name.c_str());
+  if (!media_codec_) {
+    LOG(INFO) << "Couldn't create Hybris codec by name: " << hybris_codec_name;
+    std::move(init_cb).Run(StatusCode::kDecoderInitializationFailed);
+    return;
+  }
+
+  n_buffers_in_ = media_codec_get_input_buffers_size(media_codec_);
+  n_buffers_out_ = media_codec_get_output_buffers_size(media_codec_);
+
+  output_cb_ = output_cb;
+  config_ = config;
+  frame_duration_calculator_.Reset();
+
+  gpu_task_runner_->PostTask(FROM_HERE,
+      base::BindOnce(&HybrisMediaCodecVideoDecoder::Reconfigure,
+          base::Unretained(this), std::move(init_cb)));
+}
+
+void HybrisMediaCodecVideoDecoder::FlushCodec() {
+  media_codec_flush(media_codec_);
+}
+
+bool HybrisMediaCodecVideoDecoder::PumpCodecOnce(scoped_refptr<PendingFrame> pending_frame) {
+  if (!pending_frame->processed) {
+    const bool repeat = !ProcessInput(pending_frame->buffer);
+    // Try next iteration
+    if (repeat) {
+      return false;
+    }
+    pending_frame->processed = true;
+  }
+
+  if (!pending_frame->decoded) {
+    // Tell the pipeline we're ready for more
+    if (pending_frame->decode_cb)
+      std::move(pending_frame->decode_cb).Run(DecodeStatus::OK);
+    pending_frame->decoded = true;
+  }
+
+  return true;
+}
+
+void HybrisMediaCodecVideoDecoder::PumpCodec() {
+  bool repeat = false;
+
+  // First, fill the buffers with to-be-decoded data
+  filling_ = true;
+  for (auto it = pending_frames_.begin(); it != pending_frames_.end(); it++) {
+    scoped_refptr<PendingFrame> pending_frame = *it;
+    if (pending_frame->pumped)
+      continue;
+
+    repeat = !PumpCodecOnce(pending_frame);
+    if (repeat)
+      break;
+    pending_frame->pumped = true;
+  }
+  filling_ = false;
+}
+
+bool HybrisMediaCodecVideoDecoder::DrainCodecOnce(scoped_refptr<PendingFrame> pending_frame, const bool render)
+{
+  if (!pending_frame->displayed) {
+    MediaCodecBufferInfo buffer_info_out;
+    const bool repeat = !DriveOutput(pending_frame, buffer_info_out, render);
+    if (repeat) {
+      return false;
+    }
+    pending_frame->displayed = true;
+  }
+
+  return true;
+}
+
+void HybrisMediaCodecVideoDecoder::DrainCodec(const bool render) {
+  // Allow for everything after EOS packet input & output to be ignored
+  // We don't want to touch unnecessary access to some Chromium methods
+  // because VideoBuffer::end_of_stream() is the only guaranteed one to work.
+  bool had_eos = false;
+  bool repeat = false;
+
+  // Now drain the codec and receive rendered outputs
+  draining_ = true;
+  {
+    for (auto it = pending_frames_.begin(); it != pending_frames_.end(); ) {
+      bool eraseable = false;
+      {
+        scoped_refptr<PendingFrame> pending_frame = *it;
+        if (!pending_frame->pumped)
+          break;
+
+        {
+          repeat = !DrainCodecOnce(pending_frame, render);
+          if (repeat)
+            break;
+        }
+
+        eraseable = pending_frame->released;
+        if (pending_frame->buffer->end_of_stream())
+          had_eos = true;
+      }
+
+      // Don't miss yet-to-be-decoded frames
+      if (eraseable)
+        it = pending_frames_.erase(it);
+      else
+        ++it;
+    }
+  }
+  draining_ = false;
+
+  if (had_eos)
+    FlushCodec();
+}
+
+void HybrisMediaCodecVideoDecoder::PumpAndDrainCodec(const bool render) {
+  LOG(INFO) << "Pumping and draining codec";
+
+  for (auto it = pending_frames_.begin(); it != pending_frames_.end(); ) {
+    bool erase = false;
+    bool break_out = false;
+    {
+      scoped_refptr<PendingFrame> pending_frame = *it;
+      if (PumpCodecOnce(pending_frame))
+        DrainCodecOnce(pending_frame, render);
+
+      break_out = !pending_frame->decoded;
+    }
+
+    if (erase)
+      it = pending_frames_.erase(it);
+    else if (break_out)
+      break;
+    else
+      ++it;
+  }
+
+  if (reset_cb_) {
+    auto reset_completor = base::BindOnce(std::move(reset_cb_));
+    task_runner_->PostTask(FROM_HERE, std::move(reset_completor));
+  }
+}
+
+bool HybrisMediaCodecVideoDecoder::ProcessInput(scoped_refptr<DecoderBuffer> in_flight_buffer) {
+  int32_t flags_for_input = 0;
+  size_t offset = 0;
+
+  if (in_flight_buffer->end_of_stream())
+    return true;
+
+  if (in_flight_buffer->is_key_frame()) {
+    flags_for_input |= BUFFER_FLAG_KEY_FRAME;
+  }
+
+  size_t buf_index;
+  uint8_t* input_ptr = nullptr;
+  int ret;
+  int attempts = 0;
+  static const int max_attempts = 1;
+
+  while (!input_ptr) {
+    ++attempts;
+
+    // Chances of recovery are low, try again later
+    if (attempts > max_attempts) {
+      return false;
+    }
+
+    ret = media_codec_dequeue_input_buffer(media_codec_, &buf_index, queue_timeout_);
+    if (ret >= 0) {
+      input_ptr = codec_input_buffers_[buf_index].data;
+    }
+  }
+
+  int64_t presentation_time = 0;
+  size_t capacity = 0;
+  size_t mem_size = 0;
+
+  // Fill the input buffer
+  if (!in_flight_buffer->end_of_stream() && input_ptr) {
+    capacity = codec_input_buffers_[buf_index].size;
+    mem_size = std::min<size_t>(in_flight_buffer->data_size(), capacity);
+    LOG(INFO) << "Capacity " << capacity << " vs mem_size " << mem_size;
+    if (mem_size > 0) {
+      memcpy(input_ptr, in_flight_buffer->data(), mem_size);
+    }
+
+    presentation_time = in_flight_buffer->timestamp().ToInternalValue();
+  }
+
+  // Queue it into the decoder
+  MediaCodecBufferInfo buffer_info;
+  memset(&buffer_info, 0, sizeof(buffer_info));
+  buffer_info.index = buf_index;
+  buffer_info.size = mem_size;
+  buffer_info.flags = flags_for_input;
+  buffer_info.presentation_time_us = presentation_time;
+  buffer_info.offset = offset;
+  ret = media_codec_queue_input_buffer(media_codec_, &buffer_info);
+
+  if (ret < 0) {
+    LOG(INFO) << "Error in " << __func__ << ":" << __LINE__;
+    return false;
+  }
+
+  return true;
+}
+
+void HybrisMediaCodecVideoDecoder::ClearPendingFrames(media::Status status)
+{
+  LOG(INFO) << "Clearing pending frames";
+  for (auto it = pending_frames_.begin(); it != pending_frames_.end(); ) {
+    {
+      scoped_refptr<PendingFrame> pending_frame = *it;
+      if (pending_frame->decode_cb)
+        std::move(pending_frame->decode_cb).Run(status);
+    }
+    it = pending_frames_.erase(it);
+  }
+}
+
+void HybrisMediaCodecVideoDecoder::Decode(scoped_refptr<DecoderBuffer> buffer, DecodeCB decode_cb) {
+  base::OnceClosure feedDecoderBuffer =
+      base::BindOnce(&HybrisMediaCodecVideoDecoder::FeedDecoderBuffer,
+          base::Unretained(this), buffer, std::move(decode_cb));
+  task_runner_->PostTask(FROM_HERE, std::move(feedDecoderBuffer));
+}
+
+// This method is never supposed to be canceled, else we'd lose track of decode_cb's
+// before they land in the queue and cancel the whole pipeline unnecessarily.
+void HybrisMediaCodecVideoDecoder::FeedDecoderBuffer(scoped_refptr<DecoderBuffer> buffer, DecodeCB decode_cb) {
+  LOG(INFO) << __func__;
+
+  if (!buffer) {
+    LOG(INFO) << "No buffer provided!";
+    return;
+  }
+
+  {
+    scoped_refptr<PendingFrame> pending_frame = base::MakeRefCounted<PendingFrame>();
+    pending_frame->buffer = buffer;
+    pending_frame->decode_cb = std::move(decode_cb);
+    if (!pending_frames_.empty())
+      pending_frame->previous_frame = pending_frames_.back();
+    pending_frames_.push_back(pending_frame);
+
+    auto postFrame = base::BindOnce(&HybrisMediaCodecVideoDecoder::PostFrame, base::Unretained(this), pending_frame);
+    cancelable_task_tracker_.PostTask(gpu_task_runner_.get(), FROM_HERE, std::move(postFrame));
+  }
+
+  if (!buffer->end_of_stream())
+    frame_duration_calculator_.AddSample(buffer->duration());
+
+  EnqueuePumpAndDrain(!buffer->end_of_stream());
+}
+
+void HybrisMediaCodecVideoDecoder::RedrawTexture() {
+  std::lock_guard<decltype(draw_mutex_)> lk(draw_mutex_);
+  if (stc_) {
+    decoder_context_->MakeCurrent();
+    surface_texture_client_update_texture(stc_);
+  }
+}
+
+void HybrisMediaCodecVideoDecoder::PostFrame(scoped_refptr<PendingFrame> pending_frame) {
+  std::unique_lock<std::mutex> lk(draw_mutex_);
+
+  if (pending_frame->buffer->end_of_stream())
+    return;
+
+  if (!decoder_context_)
+    return;
+
+  if (!gl_texture.get())
+    return;
+
+  if (!decoder_helper_)
+    return;
+
+  if (!stc_)
+    return;
+
+  decoder_context_->MakeCurrent();
+  gpu::MailboxHolder mailbox_holders_[VideoFrame::kMaxPlanes];
+  mailbox_holders_[0] = gpu::MailboxHolder(mailbox_, gpu::SyncToken(), GL_TEXTURE_EXTERNAL_OES);
+
+  VideoPixelFormat pixel_format = PIXEL_FORMAT_ABGR;
+  auto presentation_time = pending_frame->buffer->timestamp();
+
+  auto frame = VideoFrame::WrapNativeTextures(
+      pixel_format, mailbox_holders_, VideoFrame::ReleaseMailboxCB(),
+      coded_size_, visible_rect_, natural_size_, presentation_time);
+
+  if (!frame) {
+    return;
+  }
+
+  frame->metadata()->power_efficient = true;
+  frame->metadata()->frame_duration = pending_frame->buffer->duration();
+  frame->metadata()->reference_time = base::TimeTicks::Now();
+
+  output_cb_.Run(std::move(frame));
+}
+
+void HybrisMediaCodecVideoDecoder::Destroy() {
+  LOG(INFO) << "Destroying";
+
+  std::lock_guard<decltype(running_mutex_)> lk(running_mutex_);
+  std::lock_guard<decltype(draw_mutex_)> lk2(draw_mutex_);
+
+  cancelable_task_tracker_.TryCancelAll();
+  cancelable_codec_task_tracker_.TryCancelAll();
+
+  if (media_codec_) {
+    media_codec_flush(media_codec_);
+    media_codec_stop(media_codec_);
+    media_codec_delegate_destroy(media_codec_);
+    media_codec_ = nullptr;
+  }
+
+  if (stc_) {
+    surface_texture_client_unref(stc_);
+    stc_ = nullptr;
+  }
+
+  if (media_format_) {
+    media_format_destroy(media_format_);
+    media_format_ = nullptr;
+  }
+}
+
+void HybrisMediaCodecVideoDecoder::EnqueuePumpAndDrain(const bool render) {
+  cancelable_codec_task_tracker_.PostTask(task_runner_.get(), FROM_HERE,
+      base::BindOnce(&HybrisMediaCodecVideoDecoder::PumpAndDrainCodec, base::Unretained(this), render));
+}
+
+void HybrisMediaCodecVideoDecoder::CauseReset() {
+  {
+    auto eos_cb = base::BindOnce([](media::Status){});
+    auto eos_buffer = DecoderBuffer::CreateEOSBuffer();
+
+    base::OnceClosure feedDecoderBuffer =
+        base::BindOnce(&HybrisMediaCodecVideoDecoder::FeedDecoderBuffer,
+            base::Unretained(this), eos_buffer, std::move(eos_cb));
+    task_runner_->PostTask(FROM_HERE, std::move(feedDecoderBuffer));
+  }
+
+  task_runner_->PostTask(FROM_HERE, base::BindOnce(&HybrisMediaCodecVideoDecoder::DrainCodec,
+      base::Unretained(this), false));
+  task_runner_->PostTask(FROM_HERE, base::BindOnce(&HybrisMediaCodecVideoDecoder::ClearPendingFrames,
+      base::Unretained(this), DecodeStatus::OK));
+}
+
+void HybrisMediaCodecVideoDecoder::Reset(base::OnceClosure closure) {
+  LOG(INFO) << "Resetting";
+
+  fps_estimator_.Reset();
+  frame_duration_calculator_.Reset();
+
+  cancelable_task_tracker_.TryCancelAll();
+  cancelable_codec_task_tracker_.TryCancelAll();
+
+  reset_cb_ = std::move(closure);
+
+  task_runner_->PostTask(FROM_HERE,
+      base::BindOnce(&HybrisMediaCodecVideoDecoder::CauseReset, base::Unretained(this)));
+}
+
+bool HybrisMediaCodecVideoDecoder::NeedsBitstreamConversion() const  {
+  return true;
+}
+
+bool HybrisMediaCodecVideoDecoder::CanReadWithoutStalling() const  {
+  return false;
+}
+
+int HybrisMediaCodecVideoDecoder::GetMaxDecodeRequests() const  {
+  return n_buffers_in_;
+}
+
+std::string HybrisMediaCodecVideoDecoder::GetDisplayName() const  {
+  return "HybrisMediaCodecVideoDecoder";
+}
+
+void HybrisMediaCodecVideoDecoder::Reconfigure(InitCB init_cb) {
+  LOG(INFO) << "Configuring decoder: " << config_.AsHumanReadableString();
+
+  const int32_t width = config_.visible_rect().width();
+  const int32_t height = config_.visible_rect().height();
+  const int32_t buf_size = width * height;
+
+  media_format_ = media_format_create_video_format(codec_type_.c_str(), width, height, 0, buf_size);
+  if (supportsH264_ && config_.codec() == kCodecH264) {
+    ExtractSpsAndPps(config_.extra_data(), &csd0_, &csd1_);
+    media_format_set_byte_buffer(media_format_, "csd-0", csd0_.data(), csd0_.size());
+  }
+
+  RecreateStc(width, height);
+
+  if (!stc_ || !gl_texture.get() || media_codec_configured_ > 0) {
+    LOG(ERROR) << "Error in " << __func__ << ":" << __LINE__ << ": ret=" << media_codec_configured_;
+    std::move(init_cb).Run(StatusCode::kDecoderInitializationFailed);
+    return;
+  }
+
+  {
+    std::lock_guard<decltype(running_mutex_)> lk(running_mutex_);
+
+    media_codec_started_ = media_codec_start(media_codec_);
+    if (media_codec_started_ < 0) {
+      LOG(ERROR) << "Error in " << __func__ << ":" << __LINE__ << ": ret=" << media_codec_started_;
+      std::move(init_cb).Run(StatusCode::kDecoderInitializationFailed);
+      return;
+    }
+    running_ = true;
+
+    RecreateInputBuffers();
+    RecreateGeometry();
+  }
+
+  std::move(init_cb).Run(StatusCode::kOk);
+  LOG(INFO) << "Codec configured";
+  return;
+}
+
+void HybrisMediaCodecVideoDecoder::ExtractSpsAndPps(
+     const std::vector<uint8_t>& avcc,
+     std::vector<uint8_t>* sps_out,
+     std::vector<uint8_t>* pps_out) {
+  if (avcc.empty())
+    return;
+
+  mp4::AVCDecoderConfigurationRecord record;
+  if (!record.Parse(avcc.data(), avcc.size())) {
+    DVLOG(1) << "Failed to extract SPS and PPS";
+    return;
+  }
+
+  constexpr std::array<uint8_t, 4> prefix = {{0, 0, 0, 1}};
+  for (const std::vector<uint8_t>& sps : record.sps_list) {
+    sps_out->insert(sps_out->end(), prefix.begin(), prefix.end());
+    sps_out->insert(sps_out->end(), sps.begin(), sps.end());
+  }
+
+  for (const std::vector<uint8_t>& pps : record.pps_list) {
+    pps_out->insert(pps_out->end(), prefix.begin(), prefix.end());
+    pps_out->insert(pps_out->end(), pps.begin(), pps.end());
+  }
+}
+
+bool HybrisMediaCodecVideoDecoder::DriveOutput(scoped_refptr<PendingFrame> pending_frame,
+                                               MediaCodecBufferInfo& buffer_info_out,
+                                               const bool render) {
+  int ret = 0;
+  bool has_frame_available = false;
+
+  int attempts = 0;
+  static const int max_attempts = 3;
+
+  {
+    // Get the decoded frame
+    do {
+      memset(&buffer_info_out, 0, sizeof(buffer_info_out));
+
+      ret = media_codec_dequeue_output_buffer(media_codec_, &buffer_info_out, queue_timeout_);
+      LOG(INFO) << "buffer_info_out.flags: " << buffer_info_out.flags << ", ret: " << ret;
+
+      if (ret == INFO_TRY_AGAIN_LATER) {
+        has_frame_available = false;
+      } else if (ret == INFO_OUTPUT_BUFFERS_CHANGED) {
+        // Consider it done
+        RecreateOutputBuffers();
+        has_frame_available = false;
+      } else if (ret == INFO_OUTPUT_FORMAT_CHANGED) {
+        RecreateGeometry();
+        has_frame_available = false;
+      } else if (ret >= 0) {
+        has_frame_available = true;
+      } else {
+        return false;
+      }
+
+      ++attempts;
+    } while ((ret < 0) && attempts < max_attempts);
+
+    const bool is_eos = (buffer_info_out.flags & BUFFER_FLAG_END_OF_STREAM);
+
+    // Nothing to present yet, try again
+    if (!has_frame_available) {
+      return true;
+    }
+
+    LOG(INFO) << "buffer_info_out.presentation_time_us: " << buffer_info_out.presentation_time_us;
+
+    {
+      std::lock_guard<decltype(draw_mutex_)> lk(draw_mutex_);
+      media_codec_release_output_buffer(media_codec_, buffer_info_out.index, has_frame_available && !is_eos);
+      pending_frame->released = true;
+    }
+
+    gpu_task_runner_->PostTask(FROM_HERE,
+        base::BindOnce(&HybrisMediaCodecVideoDecoder::RedrawTexture, base::Unretained(this)));
+
+    if (buffer_info_out.presentation_time_us > 0) {
+      const auto presentation_time = base::TimeDelta::FromMicroseconds(buffer_info_out.presentation_time_us);
+      fps_estimator_.AddSample(presentation_time);
+      last_presentation_ = presentation_time;
+    }
+  }
+
+  return true;
+}
+
+bool HybrisMediaCodecVideoDecoder::RecreateInputBuffers() {
+  codec_input_buffers_.clear();
+  n_buffers_in_ = media_codec_get_input_buffers_size(media_codec_);
+  if (n_buffers_in_ <= 0) {
+    return false;
+  }
+
+  for (int32_t i = 0; i < n_buffers_in_; i++) {
+    MediaCodecBuffer media_codec_buffer;
+    media_codec_buffer.data = media_codec_get_nth_input_buffer(media_codec_, i);
+    media_codec_buffer.size = media_codec_get_nth_input_buffer_capacity(media_codec_, i);
+    codec_input_buffers_.push_back(media_codec_buffer);
+  }
+
+  return true;
+}
+
+bool HybrisMediaCodecVideoDecoder::RecreateOutputBuffers() {
+  n_buffers_out_ = media_codec_get_output_buffers_size(media_codec_);
+  if (n_buffers_out_ <= 0) {
+    return false;
+  }
+
+  for (int32_t i = 0; i < n_buffers_out_; i++) {
+    media_codec_get_nth_output_buffer(media_codec_, i);
+    media_codec_get_nth_output_buffer_capacity(media_codec_, i);
+  }
+
+  return true;
+}
+
+
+void HybrisMediaCodecVideoDecoder::RecreateGeometry()
+{
+  MediaFormat output_format = media_codec_get_output_format(media_codec_);
+
+  const int width = media_format_get_width(output_format);
+  const int height = media_format_get_height(output_format);
+  const int crop_left = media_format_get_crop_left(output_format);
+  const int crop_right = media_format_get_crop_right(output_format);
+  const int crop_bottom = media_format_get_crop_bottom(output_format);
+  const int crop_top = media_format_get_crop_top(output_format);
+
+  media_format_destroy(output_format);
+
+  gfx::Size coded_size(width, height);
+  gfx::Rect visible_rect(crop_left, crop_top, width - crop_right - crop_left, height - crop_bottom - crop_top);
+  gfx::Size natural_size(width, height);
+
+  coded_size_ = coded_size;
+  visible_rect_ = visible_rect;
+  natural_size_ = natural_size;
+}
+
+void HybrisMediaCodecVideoDecoder::RecreateStc(const int32_t width, const int32_t height)
+{
+  std::lock_guard<decltype(running_mutex_)> lk(running_mutex_);
+
+  if (stc_) {
+    surface_texture_client_unref(stc_);
+    stc_ = nullptr;
+  }
+
+  decoder_context_->MakeCurrent();
+  gl_texture = decoder_helper_->CreateTexture(GL_TEXTURE_EXTERNAL_OES, GL_RGBA, width, height, GL_RGBA, GL_UNSIGNED_BYTE);
+  if (!gl_texture.get()) {
+    LOG(ERROR) << "Error in " << __func__ << ":" << __LINE__;
+    return;
+  }
+  mailbox_ = decoder_helper_->CreateMailbox(gl_texture.get());
+
+  stc_ = surface_texture_client_create_by_id(gl_texture->service_id());
+  if (!stc_) {
+    LOG(ERROR) << "Error in " << __func__ << ":" << __LINE__;
+    return;
+  }
+
+  surface_texture_client_ref(stc_);
+  surface_texture_client_set_hardware_rendering(stc_, true);
+
+  LOG(INFO) << "Reconfiguring media codec";
+  media_codec_configured_ = media_codec_configure(media_codec_, media_format_, stc_, 0);
+}
+
+bool HybrisVideoDecoder::IsSupported() {
+  static const bool hybris_available = media_compat_check_availability();
+  return hybris_available;
+}
+
+std::unique_ptr<VideoDecoder> HybrisVideoDecoder::Create(
+    scoped_refptr<base::SingleThreadTaskRunner> task_runner,
+    scoped_refptr<base::SingleThreadTaskRunner> gpu_task_runner,
+    GetStubCB stub_cb) {
+  return std::unique_ptr<VideoDecoder>(new HybrisMediaCodecVideoDecoder(task_runner, gpu_task_runner, stub_cb));
+}
+
+}  // namespace media
diff --git a/qtwebengine-chromium/chromium/media/gpu/hybris/video_decoder_hybris.h b/qtwebengine-chromium/chromium/media/gpu/hybris/video_decoder_hybris.h
new file mode 100644
index 000000000..33cc96fb2
--- /dev/null
+++ b/qtwebengine-chromium/chromium/media/gpu/hybris/video_decoder_hybris.h
@@ -0,0 +1,193 @@
+// Copyright 2022 Alfred Neumayer. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef MEDIA_GPU_VIDEO_DECODE_HYBRIS_ACCELERATOR_OVERRIDE_H_
+#define MEDIA_GPU_VIDEO_DECODE_HYBRIS_ACCELERATOR_OVERRIDE_H_
+
+#include "media/base/video_decoder.h"
+#include "media/base/video_decoder_config.h"
+#include "media/base/frame_rate_estimator.h"
+#include "media/base/moving_average.h"
+#include "media/gpu/media_gpu_export.h"
+#include "media/video/supported_video_decoder_config.h"
+#include "base/memory/ptr_util.h"
+#include "base/timer/timer.h"
+#include "base/task/cancelable_task_tracker.h"
+#include "gpu/config/gpu_preferences.h"
+#include "media/gpu/gles2_decoder_helper.h"
+#include "gpu/command_buffer/service/mailbox_manager.h"
+#include "gpu/command_buffer/service/texture_manager.h"
+#include "media/base/video_frame.h"
+
+#include <memory>
+#include <set>
+#include <vector>
+#include <chrono>
+#include <mutex>
+#include <condition_variable>
+
+#include <hybris/media/media_codec_list.h>
+#include <hybris/media/media_codec_layer.h>
+#include <hybris/media/media_format_layer.h>
+#include <hybris/media/surface_texture_client_hybris.h>
+
+namespace gpu {
+class CommandBufferStub;
+}
+
+namespace media {
+
+using GetStubCB = base::RepeatingCallback<gpu::CommandBufferStub*()>;
+
+class MEDIA_GPU_EXPORT HybrisMediaCodecVideoDecoder : public VideoDecoder
+{
+public:
+  static std::vector<SupportedVideoDecoderConfig> GetSupportedConfigs();
+
+  HybrisMediaCodecVideoDecoder(
+      scoped_refptr<base::SingleThreadTaskRunner> task_runner,
+      scoped_refptr<base::SingleThreadTaskRunner> gpu_task_runner,
+      GetStubCB stub_cb);
+
+protected:
+  ~HybrisMediaCodecVideoDecoder() override;
+
+private:
+  static std::vector<SupportedVideoDecoderConfig> GetSupportedConfigsInternal();
+  static bool IsSupportedProfile(VideoCodecProfile type);
+  static bool IsSupported(VideoCodecProfile type);
+  static const char* MimeTypeForCodecType(VideoCodecProfile type);
+  static std::string FindSuitableCodec(const std::string& codec_type, const bool hwCodecOnly);
+
+public:
+  void Initialize(const VideoDecoderConfig& config,
+                  bool low_delay,
+                  CdmContext* cdm_context,
+                  InitCB init_cb,
+                  const OutputCB& output_cb,
+                  const WaitingCB& waiting_cb) override;
+
+  void Decode(scoped_refptr<DecoderBuffer> buffer, DecodeCB decode_cb) override;
+
+  // Decoder implementation
+  bool IsPlatformDecoder() const final;
+  bool SupportsDecryption() const final;
+  std::string GetDisplayName() const final;
+
+  // VideoDecoder implementation
+  void Reset(base::OnceClosure closure) override;
+  bool NeedsBitstreamConversion() const override;
+  bool CanReadWithoutStalling() const override;
+  int GetMaxDecodeRequests() const override;
+
+private:
+  struct MediaCodecBuffer {
+    uint8_t* data;
+    size_t size;
+  };
+
+  struct PendingFrame : public base::RefCounted<PendingFrame> {
+    PendingFrame() : displayed(false), processed(false), decoded(false), posted(false), pumped(false) {}
+    scoped_refptr<DecoderBuffer> buffer;
+    DecodeCB decode_cb;
+    bool displayed;
+    bool processed;
+    bool decoded;
+    bool posted;
+    bool pumped;
+    bool released;
+    scoped_refptr<PendingFrame> previous_frame;
+  private:
+    friend class RefCounted<PendingFrame>;
+  };
+
+  void FeedDecoderBuffer(scoped_refptr<DecoderBuffer> buffer, DecodeCB decode_cb);
+  void PostFrame(scoped_refptr<PendingFrame> pending_frame);
+  void RedrawTexture();
+  void Destroy();
+  void Reconfigure(InitCB init_cb);
+  void CauseReset();
+  void EnsurePeriodicPump();
+  void EnqueuePumpAndDrain(const bool render);
+  bool ProcessInput(scoped_refptr<DecoderBuffer> in_flight_buffer);
+  void PumpAndDrainCodec(const bool force = true);
+  void PumpCodec();
+  bool PumpCodecOnce(scoped_refptr<PendingFrame> pending_frame);
+  void DrainCodec(const bool render = true);
+  bool DrainCodecOnce(scoped_refptr<PendingFrame> pending_frame, const bool render);
+  void FlushCodec();
+  bool DriveOutput(scoped_refptr<PendingFrame> pending_frame, MediaCodecBufferInfo& buffer_info_out, const bool render);
+
+  void ClearPendingFrames(media::Status status);
+  void ExtractSpsAndPps(
+    const std::vector<uint8_t>& avcc,
+    std::vector<uint8_t>* sps_out,
+    std::vector<uint8_t>* pps_out);
+
+  bool RecreateInputBuffers();
+  bool RecreateOutputBuffers();
+  void RecreateGeometry();
+  void RecreateStc(const int32_t width, const int32_t height);
+
+  OutputCB output_cb_;
+  base::OnceClosure reset_cb_;
+
+  bool running_;
+  std::atomic<bool> filling_;
+  std::atomic<bool> draining_;
+
+  int32_t n_buffers_in_;
+  int32_t n_buffers_out_;
+
+  std::vector<MediaCodecBuffer> codec_input_buffers_;
+  int32_t queue_timeout_;
+
+  std::mutex running_mutex_;
+  std::mutex draw_mutex_;
+
+  MediaCodecDelegate media_codec_;
+  int media_codec_configured_;
+  int media_codec_started_;
+  MediaFormat media_format_;
+  SurfaceTextureClientHybris stc_;
+  gpu::Mailbox mailbox_;
+
+  gpu::DecoderContext* decoder_context_;
+  std::unique_ptr<GLES2DecoderHelper> decoder_helper_;
+  std::unique_ptr<gpu::gles2::AbstractTexture> gl_texture;
+
+  std::string codec_type_;
+  VideoDecoderConfig config_;
+
+  base::CancelableTaskTracker cancelable_task_tracker_;
+  base::CancelableTaskTracker cancelable_codec_task_tracker_;
+  scoped_refptr<base::SingleThreadTaskRunner> task_runner_;
+  scoped_refptr<base::SingleThreadTaskRunner> gpu_task_runner_;
+
+  gfx::Size coded_size_;
+  gfx::Rect visible_rect_;
+  gfx::Size natural_size_;
+  std::vector<uint8_t> csd0_;
+  std::vector<uint8_t> csd1_;
+
+  bool supportsH264_;
+  FrameRateEstimator fps_estimator_;
+  MovingAverage frame_duration_calculator_;
+  base::TimeDelta last_presentation_;
+
+  std::deque<scoped_refptr<PendingFrame> > pending_frames_;
+};
+
+class MEDIA_GPU_EXPORT HybrisVideoDecoder {
+ public:
+  static bool IsSupported();
+  static std::unique_ptr<VideoDecoder> Create(
+      scoped_refptr<base::SingleThreadTaskRunner> task_runner,
+      scoped_refptr<base::SingleThreadTaskRunner> gpu_task_runner,
+      GetStubCB stub_cb);
+};
+
+}  // namespace media
+
+#endif  // MEDIA_GPU_VIDEO_DECODE_HYBRIS_ACCELERATOR_OVERRIDE_H_
diff --git a/qtwebengine-chromium/chromium/media/media_options.gni b/qtwebengine-chromium/chromium/media/media_options.gni
index acacfcd62..852d9b745 100644
--- a/qtwebengine-chromium/chromium/media/media_options.gni
+++ b/qtwebengine-chromium/chromium/media/media_options.gni
@@ -213,7 +213,7 @@ if (is_chromecast) {
     "video_decoder",
   ]
   _default_mojo_media_host = "gpu"
-} else if (is_chromeos || is_mac || is_win || (is_linux && use_vaapi)) {
+} else if (is_chromeos || is_mac || is_win || is_linux) {
   _default_mojo_media_services = [ "video_decoder" ]
   _default_mojo_media_host = "gpu"
 }
diff --git a/qtwebengine-chromium/chromium/media/mojo/services/BUILD.gn b/qtwebengine-chromium/chromium/media/mojo/services/BUILD.gn
index 0782f9fd2..efa3220b4 100644
--- a/qtwebengine-chromium/chromium/media/mojo/services/BUILD.gn
+++ b/qtwebengine-chromium/chromium/media/mojo/services/BUILD.gn
@@ -4,9 +4,14 @@
 
 import("//build/config/chromecast_build.gni")
 import("//build/config/jumbo.gni")
+import("//build/config/linux/pkg_config.gni")
 import("//media/media_options.gni")
 import("//testing/test.gni")
 
+pkg_config("libmedia") {
+  packages = [ "libmedia" ]
+}
+
 jumbo_component("services") {
   output_name = "media_mojo_services"
   sources = [
@@ -144,6 +149,9 @@ jumbo_component("services") {
     deps +=
         [ "//chromeos/components/cdm_factory_daemon:cdm_factory_daemon_gpu" ]
   }
+  if (is_linux) {
+    defines += [ "ENABLE_HYBRIS_MEDIA" ]
+  }
 }
 
 source_set("unit_tests") {
diff --git a/qtwebengine-chromium/chromium/media/mojo/services/gpu_mojo_media_client.cc b/qtwebengine-chromium/chromium/media/mojo/services/gpu_mojo_media_client.cc
index b1f553ce7..4d53d0c05 100644
--- a/qtwebengine-chromium/chromium/media/mojo/services/gpu_mojo_media_client.cc
+++ b/qtwebengine-chromium/chromium/media/mojo/services/gpu_mojo_media_client.cc
@@ -40,6 +40,10 @@
 #include "media/mojo/services/mojo_provision_fetcher.h"
 #endif  // defined(OS_ANDROID)
 
+#if defined(ENABLE_HYBRIS_MEDIA)
+#include "media/gpu/hybris/video_decoder_hybris.h"
+#endif
+
 #if defined(OS_WIN)
 #include "media/gpu/windows/d3d11_video_decoder.h"
 #include "ui/gl/direct_composition_surface_win.h"
@@ -168,9 +172,16 @@ GpuMojoMediaClient::GetSupportedVideoDecoderConfigs() {
        MediaCodecVideoDecoder::GetSupportedConfigs()},
   };
   return supported_configs;
+
+#elif defined(ENABLE_HYBRIS_MEDIA)
+  static SupportedVideoDecoderConfigMap supported_configs{
+      {VideoDecoderImplementation::kDefault,
+       HybrisMediaCodecVideoDecoder::GetSupportedConfigs()},
+  };
+  return supported_configs;
+
 #else
   SupportedVideoDecoderConfigMap supported_config_map;
-
 #if defined(OS_WIN)
   // Start with the configurations supported by D3D11VideoDecoder.
   // VdaVideoDecoder is still used as a fallback.
@@ -305,13 +316,23 @@ std::unique_ptr<VideoDecoder> GpuMojoMediaClient::CreateVideoDecoder(
       if (gpu_workarounds_.disable_dxva_video_decoder)
         return nullptr;
 #endif  // defined(OS_WIN)
-      video_decoder = VdaVideoDecoder::Create(
-          task_runner, gpu_task_runner_, media_log->Clone(), target_color_space,
-          gpu_preferences_, gpu_workarounds_,
-          base::BindRepeating(&GetCommandBufferStub, gpu_task_runner_,
-                              media_gpu_channel_manager_,
-                              command_buffer_id->channel_token,
-                              command_buffer_id->route_id));
+#if defined(ENABLE_HYBRIS_MEDIA)
+      if (HybrisVideoDecoder::IsSupported())
+        video_decoder = HybrisVideoDecoder::Create(
+            task_runner, gpu_task_runner_,
+            base::BindRepeating(&GetCommandBufferStub, gpu_task_runner_,
+                                media_gpu_channel_manager_,
+                                command_buffer_id->channel_token,
+                                command_buffer_id->route_id));
+      else
+#endif // defined(ENABLE_HYBRIS_MEDIA)
+        video_decoder = VdaVideoDecoder::Create(
+            task_runner, gpu_task_runner_, media_log->Clone(), target_color_space,
+            gpu_preferences_, gpu_workarounds_,
+            base::BindRepeating(&GetCommandBufferStub, gpu_task_runner_,
+                                media_gpu_channel_manager_,
+                                command_buffer_id->channel_token,
+                                command_buffer_id->route_id));
 #endif  // defined(OS_ANDROID)
     } break;
 
diff --git a/src/core/core_module.pro b/src/core/core_module.pro
index 75e8488b4..16af9caa7 100644
--- a/src/core/core_module.pro
+++ b/src/core/core_module.pro
@@ -11,7 +11,7 @@ api_library_name = qtwebenginecoreapi$$qtPlatformTargetSuffix()
 api_library_path = $$OUT_PWD/api/$$getConfigDir()
 LIBS_PRIVATE += -L$$api_library_path
 linux:LIBS_PRIVATE += -landroid-properties
-linux:LIBS_PRIVATE += -lhybris-common -lcamera
+linux:LIBS_PRIVATE += -lhybris-common -lcamera -lmedia
 CONFIG *= no_smart_library_merge
 osx {
     LIBS_PRIVATE += -Wl,-force_load,$${api_library_path}$${QMAKE_DIR_SEP}lib$${api_library_name}.a
-- 
2.39.2 (Apple Git-143)

